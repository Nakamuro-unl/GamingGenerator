<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GIF処理クイックテスト</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            padding: 20px;
            background: #000;
            color: #0f0;
            line-height: 1.6;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
        }
        .test-area {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #0f0;
            background: #001100;
        }
        canvas {
            border: 1px solid #0f0;
            margin: 10px;
        }
        img {
            border: 1px solid #0f0;
            margin: 10px;
        }
        .log {
            background: #000;
            color: #0f0;
            padding: 10px;
            font-size: 12px;
            max-height: 300px;
            overflow-y: scroll;
            white-space: pre-wrap;
        }
        button {
            background: #003300;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 10px 20px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #005500;
        }
        .success { color: #0f0; }
        .error { color: #f00; }
        .warning { color: #ff0; }
        .info { color: #0ff; }
    </style>
</head>
<body>
    <div class="container">
        <h1>🎮 GIF処理クイックテスト</h1>
        
        <div class="test-area">
            <h2>1. ゲーミング効果プレビュー</h2>
            <canvas id="gamingCanvas" width="256" height="256"></canvas>
            <img id="gifPreview" width="256" height="256" style="display: none;">
            <br>
            <button onclick="startGamingAnimation()">ゲーミング効果開始</button>
            <button onclick="stopGamingAnimation()">停止</button>
        </div>
        
        <div class="test-area">
            <h2>2. GIF読み込みテスト</h2>
            <input type="file" id="gifInput" accept="image/gif" onchange="handleGifUpload(event)">
            <div id="gifInfo" class="log"></div>
        </div>
        
        <div class="test-area">
            <h2>3. API接続テスト</h2>
            <button onclick="testApiConnection()">API接続テスト</button>
            <div id="apiLog" class="log"></div>
        </div>
        
        <div class="test-area">
            <h2>4. 統合テスト</h2>
            <button onclick="runFullTest()">完全テスト実行</button>
            <div id="fullTestLog" class="log"></div>
        </div>
        
        <div class="test-area">
            <h2>5. システムログ</h2>
            <div id="systemLog" class="log"></div>
        </div>
    </div>

    <script>
        let gamingAnimationId = null;
        let systemLogElement = document.getElementById('systemLog');
        
        // ログ出力用ヘルパー
        function log(message, type = 'info', containerId = 'systemLog') {
            const container = document.getElementById(containerId);
            const timestamp = new Date().toLocaleTimeString();
            const className = type;
            const logEntry = `[${timestamp}] ${message}\n`;
            
            container.innerHTML += `<span class="${className}">${logEntry}</span>`;
            container.scrollTop = container.scrollHeight;
            
            // コンソールにも出力
            console.log(logEntry.trim());
        }
        
        // 1. ゲーミング効果アニメーション
        function startGamingAnimation() {
            const canvas = document.getElementById('gamingCanvas');
            const ctx = canvas.getContext('2d');
            let progress = 0;
            
            log('ゲーミング効果アニメーション開始', 'success');
            
            function animate() {
                // 背景をクリア
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // 虹色グラデーション効果
                for (let x = 0; x < canvas.width; x++) {
                    const hue = (x / canvas.width * 360 + progress * 36) % 360;
                    
                    // HSVからRGBに変換
                    const h = hue / 60.0;
                    const c = 255;
                    const x_val = c * (1 - Math.abs((h % 2) - 1));
                    
                    let r, g, b;
                    if (0 <= h && h < 1) {
                        r = c; g = x_val; b = 0;
                    } else if (1 <= h && h < 2) {
                        r = x_val; g = c; b = 0;
                    } else if (2 <= h && h < 3) {
                        r = 0; g = c; b = x_val;
                    } else if (3 <= h && h < 4) {
                        r = 0; g = x_val; b = c;
                    } else if (4 <= h && h < 5) {
                        r = x_val; g = 0; b = c;
                    } else {
                        r = c; g = 0; b = x_val;
                    }
                    
                    ctx.strokeStyle = `rgba(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)}, 0.7)`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                
                progress += 0.1;
                gamingAnimationId = requestAnimationFrame(animate);
            }
            
            gamingAnimationId = requestAnimationFrame(animate);
        }
        
        function stopGamingAnimation() {
            if (gamingAnimationId) {
                cancelAnimationFrame(gamingAnimationId);
                gamingAnimationId = null;
                log('ゲーミング効果アニメーション停止', 'warning');
            }
        }
        
        // 2. GIF読み込み処理
        async function handleGifUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            log(`GIFファイル選択: ${file.name} (${file.size} bytes)`, 'info', 'gifInfo');
            
            try {
                // ファイル基本情報
                const isGif = file.type === 'image/gif' || file.name.toLowerCase().endsWith('.gif');
                if (!isGif) {
                    log('GIFファイルではありません', 'error', 'gifInfo');
                    return;
                }
                
                // 画像として読み込み
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const img = new Image();
                    img.onload = () => {
                        log(`画像サイズ: ${img.width}x${img.height}`, 'success', 'gifInfo');
                        
                        // プレビュー表示
                        const preview = document.getElementById('gifPreview');
                        preview.src = e.target.result;
                        preview.style.display = 'block';
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
                
                // フレーム数検出
                const frameCount = await detectGifFrameCount(file);
                log(`推定フレーム数: ${frameCount}`, 'info', 'gifInfo');
                
            } catch (error) {
                log(`GIF処理エラー: ${error.message}`, 'error', 'gifInfo');
            }
        }
        
        // GIFフレーム数検出
        async function detectGifFrameCount(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const arrayBuffer = e.target.result;
                        const uint8View = new Uint8Array(arrayBuffer);
                        
                        // GIFヘッダーチェック
                        const header = String.fromCharCode(...uint8View.slice(0, 6));
                        if (!header.startsWith('GIF')) {
                            reject(new Error('有効なGIFファイルではありません'));
                            return;
                        }
                        
                        // フレーム数推定
                        let frameCount = 0;
                        for (let i = 0; i < uint8View.length - 3; i++) {
                            if (uint8View[i] === 0x21 && uint8View[i + 1] === 0xF9) {
                                frameCount++;
                            }
                        }
                        
                        resolve(Math.max(1, Math.min(frameCount, 100)));
                        
                    } catch (error) {
                        reject(error);
                    }
                };
                reader.readAsArrayBuffer(file);
            });
        }
        
        // 3. API接続テスト
        async function testApiConnection() {
            log('API接続テスト開始', 'info', 'apiLog');
            
            const apiUrls = [
                window.location.origin,
                'https://gaming-generator-qjlika608-nakamuros-projects-f99bfc51.vercel.app',
                'https://gaming-generator.vercel.app'
            ];
            
            for (const apiUrl of apiUrls) {
                try {
                    log(`テスト中: ${apiUrl}/api/test`, 'info', 'apiLog');
                    
                    const response = await fetch(`${apiUrl}/api/test`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ test: true })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        log(`✅ ${apiUrl} - 接続成功: ${data.message}`, 'success', 'apiLog');
                        return apiUrl;
                    } else {
                        log(`❌ ${apiUrl} - HTTP ${response.status}`, 'error', 'apiLog');
                    }
                } catch (error) {
                    log(`❌ ${apiUrl} - ${error.message}`, 'error', 'apiLog');
                }
            }
            
            log('全てのAPI接続に失敗', 'error', 'apiLog');
        }
        
        // 4. 完全テスト実行
        async function runFullTest() {
            log('===== 完全テスト開始 =====', 'info', 'fullTestLog');
            
            try {
                // ゲーミング効果テスト
                log('1. ゲーミング効果テスト', 'info', 'fullTestLog');
                startGamingAnimation();
                await new Promise(resolve => setTimeout(resolve, 2000));
                stopGamingAnimation();
                log('✅ ゲーミング効果テスト完了', 'success', 'fullTestLog');
                
                // API接続テスト
                log('2. API接続テスト', 'info', 'fullTestLog');
                try {
                    const workingApi = await testApiConnection();
                    log(`✅ 利用可能API: ${workingApi}`, 'success', 'fullTestLog');
                } catch (error) {
                    log(`⚠️ API接続失敗: ${error.message}`, 'warning', 'fullTestLog');
                }
                
                // GIFテスト（test_animated.gifがある場合）
                log('3. GIFファイルテスト', 'info', 'fullTestLog');
                try {
                    const response = await fetch('/test_animated.gif');
                    if (response.ok) {
                        const blob = await response.blob();
                        const frameCount = await detectGifFrameCount(blob);
                        log(`✅ テストGIF: ${blob.size} bytes, ${frameCount} フレーム`, 'success', 'fullTestLog');
                    } else {
                        log('⚠️ テストGIFファイルが見つかりません', 'warning', 'fullTestLog');
                    }
                } catch (error) {
                    log(`⚠️ GIFテストエラー: ${error.message}`, 'warning', 'fullTestLog');
                }
                
                log('===== 全テスト完了 =====', 'success', 'fullTestLog');
                
            } catch (error) {
                log(`❌ テスト実行エラー: ${error.message}`, 'error', 'fullTestLog');
            }
        }
        
        // 初期化
        log('GIF処理クイックテスト準備完了', 'success');
        log('各セクションのボタンを使用してテストを実行してください', 'info');
        
        // 自動でゲーミング効果をプレビュー
        setTimeout(startGamingAnimation, 1000);
    </script>
</body>
</html>